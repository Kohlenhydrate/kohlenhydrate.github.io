---
layout:       post
title:        迟到一年的「龙芯杯」回顾
subtitle:    「造计算机」及「龙芯杯」顺序及乱序双发射的尝试
hidesubtitle: true
author:       miskcoo
catalog:      true
copyright:    "NO"
tags:
    - 流水账
    - FPGA
---

> <s>奋战三星期，造台计算机！    ——刘卫东老师</s>
>
> 奋战八星期，造台真正的计算机！  ——杰哥

这是一个关于我本科期间从学习 FPGA，和同学「造计算机」，2019 年暑期参加「龙芯杯」的流水账。同时，也是在贵系期间学习系统类课程的一个回顾。

在此感谢几个项目中我的队友们。另外，文中有部分内容以及引用来自对应项目的文档和展示。

# 缘起

如果扣除「电子学基础」的话，在贵系真正意义上碰到硬件是在大二下学期的「数字逻辑电路」或者「数字逻辑设计」，它们分别被称为「数电」和「数设」。在培养方案里这两门课程是任选一门即可。「数电」讲得相对慢一些，它是大班上课同时内容也相对偏向理论一些，而「数设」是小班上课，会在前半学期把「数电」的主要内容讲完并且在进行一个考试之后就进入做项目的阶段，会有更多的实践。当然，并行的还有一门「数字逻辑实验」课程会进行一些简单的 FPGA 相关的实验，为下个学期的「计算机组成原理」打下基础。

对于之前没有接触过硬件相关的我来说在两门课程中自然是更倾向于选择「数电」而不是「数设」。然而不幸的是，这个学期的二学位课程中的「概率论」和「数电」恰好在同一个时间。因为并不想把它们中的任何一门推迟到一年后再上，所以剩下的选择就只能是在另一个时间的「数设」了。我和另一位和我情况相同的同学 [HarryChen](https://harrychen.xyz) 便组团选了「数设」。

就这样阴差阳错地，之后断断续续持续了大约一年半的「硬件生活」开始了。

# 初识 FPGA

刚刚提到，在「数设」后半学期大家需要组队来利用 FPGA 做一些有趣的项目。HarryChen 提出可以做一个硬件的虚拟字符终端。这是一个十分复古的东西，现在大部分的操作系统都是内置有虚拟终端，就像 Linux 下的 xterm、gnome-terminal。但是，在最初控制台和计算机是相互独立的。控制台一般是由键盘和屏幕组成，键盘将用户输入传入计算机，计算机将输出发送显示给用户。这整个通信的过程是有一套标准来规定的，由于计算机回显的数据并不是单纯地整个屏幕的像素数据，而是更高层次的类似控制命令的内容，例如表示光标移动到某个位置，在某个位置插入某个字符，删除某一行的字符等。这些标准主要是定义了计算机发送回的这些控制命令的行为，和键盘发送给计算机的控制命令的行为。

我们想要做的就是利用 FPGA 模拟一个这样的终端，它通过 FPGA 接收键盘的输入，并且转化为控制命令通过串口输出给计算机。同时也通过串口接受计算机传回的控制命令名且解析、执行，修改对应位置的字符，再将字符进行渲染通过 VGA 输出到屏幕。类似于没有电脑的显示器，而是利用 FPGA 实现了一个接收用户输入、和计算机交互并且将结果渲染成字符显示的东西。最后的结果看起来类似下面这样

![](/img/in-post/fpga-camera.gif)

这里是用 ffmpeg 将笔记本的摄像头拍摄得到的视频转为字符再通过串口输出到 FPGA 上，而后 FPGA 再渲染到显示器上的结果。

由于 HarryChen 十分厉害，整个项目的过程中并没有太大的波折。最麻烦的和外设打交道的操作他都很好地解决了，现在回想起来我似乎只是实现了下面这个巨大的状态机用以解析电脑传回的控制序列，并且根据解析出的命令修改缓冲区中的字符。至于渲染到屏幕的过程并不需要我操心。

![](/img/in-post/cpu/vterm-fa0.png)

这个项目最开始老师就担心我们如何展示，因为这门课程最后是同学和老师们根据各个组展示的结果来进行打分的。最初看起来这个黑乎乎的终端的展示效果肯定不如做游戏的组来得好。但是，最后我们优化后发现，在把串口默认波特率从 115200 调整为 3M 之后，能够以 25fps 的速率流畅播放彩色字符视频。类似上文中的图上一样，得到了一个看起来很酷的效果！

在实现的过程中遇到的一个稍微麻烦的 bug 大概是在尝试播放「Bad Apple」时有时整个字符渲染会出错。看起来大概是某个控制命令的实现或者解析不太正确。虽然这时我还并不会用 ILA 来进行调试，但是某天我突然发现我们实际上可以在某种意义上进行「单步执行」。因为本质上 FPGA 的渲染行为取决于控制序列，而控制序列是通过电脑发送的，我们只需要实现记录下相应的控制序列之后逐条发送就可以精确地找到出现问题的那一个点进而进行 bug 的调试。终于，在大约数 MB 的控制序列数据中我们找到了出现问题的地点……

# 奋战 X 星期，造台计算机

在贵系流传着「奋战三星期，造台计算机」的口号，每年大三上学期总会有那么一天类似下面的图片刷爆朋友圈，而后贵系同学开始集体失联，上课变得无精打采……

![奋战三星期，造台计算机](/img/in-post/cpu/three-week.jpg)

刘老师提出的口号可以说是「计算机组成原理」课程的标志，也是大三上学期大家需要努力迈过的一个槛。除了「组成原理」外，这学期还有一门「软件工程」，它和「组成原理」有一个联合实验，大致上可以认为是按照软件工程的要求来「造机」。
因为种种原因，我在前一年先上了「软件工程」但没上「组成原理」，再加上 HarryChen 和另一个情况恰好相反的学长，我们组成了一个平均每人选了 4/3 门课的奇怪队伍参加了这两门课的联合实验。当然，因为联合实验的要求比普通高一些，「三星期」也延长到了约「一学期」。

#### 第一步 -- 抄书

之后我们商量了一下分工，我因为之前「数设」时主要写的是内部逻辑的部分，于是在「造机」中就主要负责写流水线。我们需要实现的是编写一个 32 位的 MIPS 处理器。这里实际上有一本在同学之间很有名的书，是雷思磊写的「自己动手写CPU」。在最开始，老师讲完流水线的基本结构之后有一本如此详细的书教你如何用代码实现它确实是一件幸运的事。和学习其它编程语言一样，我们的这个名叫「TrivialMIPS」的 CPU 最初也是从「抄书」开始的。

当然，有了一个好老师之后，最初「TrivialMIPS」的五级流水线很快就完成了。因为「软件工程」的要求，同时也是保证实现正确性的必要步骤，我参考张宇翔学长的 [NaiveMIPS](https://github.com/z4yx/NaiveMIPS-HDL) 在一番修改之后写了一个用于黑盒测试的仿真代码。大体上是在人工编写测例以及各个指令对寄存器写操作的答案后，在仿真中比较 CPU 对寄存器的写入是否是预期的值。这个仿真代码以及相关的测例在之后数次的 CPU 设计中发挥了很大的作用。

和前一年「软件工程」的项目体验相比，或许「组成原理」这个场景更能让人感受到「软件工程」中测试这一过程的重要性。因为它真的是在你想要很好地完成这个设计时必不可少的一环，而不是像其它一些项目实践中为了刷覆盖率而写的糟糕并且无意义的测试一般。

#### 做个双发射吧！

> 「做个双发射吧！」  
> 「什么是双发射？」

在我将流水线基本完成要写和启动系统相关的内存管理单元（MMU）和相关的协处理器（CP0）时，Harry 告诉我张宇翔学长建议我们可以做个双发射。当然，这时候「计算机系统结构」这门课是还没有学的。在听说还可以在一个周期发射两条指令之后我花了一个晚上时间脑补了这样的流水线应该长什么样。最初想来似乎是一件很简单的事情，听起来只要把现有的模块「复制」和「粘贴」一次就完事了。然而，在之后实现的过程中遇到了各种各样没有考虑清楚的细节……

总之，在思考完了大致的设计之后向 Harry 确认了地址线在一个周期内能够提供物理上连续的 64 位的数据我就开始了从现在五级单发射流水线到（顺序）双发射的改造。当然，大部分操作的确像是「复制」和「粘贴」，但是最后问题往往都出在剩下的地方。比如，在两条指令跨越一页的边界时，它们在物理上可能不是连续的，这会导致取指得到的后 32 位数据实际上应该不可用。又或者，在取指得到两条指令后究竟发射一条、两条还是暂停要在之后的流水段才能决定，那么在取指阶段如何确定下一个周期 PC 值又成了一个麻烦的问题。在这时的设计我是通过一个只有写的时候才想明白的状态机来控制的，这也加大了之后增加分支预测时的困难，使得我们在最后并没有很好地调通分支预测相关模块。这也是在之后「龙芯杯」重写的原因之一。

一段时间后，看起来我们成功得到了一个双发射的流水线，并且在一些性能测试上每条指令的平均周期数（IPC）大约能够提高 30%。剩下的一段时间我给它加上了运行操作系统必要的一些模块之后我们就开始考虑运行操作系统和一些额外的功能展示了。不过这就不属于我负责的范围内了。

#### 还能放视频吗？

> 播放「Bad Apple」似乎成为了我们展示的最终目标？

在队友调试操作系统和准备展示内容的过程中，我暴力地给这个流水线添加了一个浮点单元，当然其中所有的浮点运算都用了 Xilinx 的 IP 核。同时，队友移植了一个绘制 Mandelbrot 集合的[程序](https://github.com/miskcoo/mandelbrot-render)。它是过不断地迭代逐点计算各个像素的值。就这样，我们有了一个可以证明我们有浮点单元的用于展示的图形程序，效果看起来类似下图

![](/img/in-post/cpu/mandel.gif)

因为有了「数设」中播放视频的良好体验，我们这次自然也有着实时播放视频的目标。但是这回和「数设」有着很大的不同。首先，我们用于播放视频的程序需要运行在操作系统上，这会带来一些额外的开销。其次，用于播放的数据也需要用软件加载并且写入显存，同「数设」直接硬件解析并且操作显存相比必然会慢上不少。在最初的实现中，我们大约仅有 ~2fps 的帧率，整个视频几乎卡成了 PPT。此外，还有一个令人头疼的问题，这块板子上的内存仅有 8MB，扣除操作系统所需的用于存储视频的空间严重不足，即使是黑白二值视频也无法存储较长时间。

思来想去，内存的问题似乎最容易解决，我们可以用类似 LZ77 的压缩的办法，大致上用（像素值，重复次数）这样一个序对来表示连续的一串像素。那么解压要怎么办呢？我们可以改硬件呀！可以直接在相应地址写入压缩的数据，让硬件直接解压。这样带来的好处还有一个写指令能够同时修改多个像素。最终测试下帧率大约能够达到 20fps！「Bad Apple」又一次成功地播放了。

另外，我们顺便把展示用的 PPT 也放入了「TrivialMIPS」上，最后用它来进行展示。

#### 展示前的夜晚

> 突如其来的 Bug……

一切似乎都顺利地进行着，最后播放视频、PPT 和浮点单元的示例都完成了并且也运行起了教学操作系统「ucore」。但是在展示前一天我们开始准备最后的内容时，突然发现不知什么原因，有些程序有时会突然运行到 `0x00000000` 这个地址上而崩溃。虽然它出现的频率还可以接受，但是多少还是会影响展示的。

我们晚上聚到了 308 房间开始处理这个问题。最开始毫无头绪，但是重复了一段时间对现象进行观察，发现似乎随机地快速键盘输入一些东西更容易出发这个问题，看起来似乎和中断有些关系？通过 ILA 进行信号抓取后才发现，原来在中断处理时有一个细节没有考虑到。也就是中断可能会在流水线上的气泡触发，而导致 `EPC` 为 0，并且之后异常返回时就到了不正确的地址。

现在回头看了一下这个 [commit](https://github.com/trivialmips/TrivialMIPS/commit/44ba74001ba4bb71db18e66236803cdf34662dfc) 的提交时间居然是凌晨三点多了。虽然现在并没有已知的 bug 了，但是故事并没有结束，在之后「操作系统」课程上我们还遇到了更多隐藏的问题。

因为没有肉眼可见的问题，并且第二天的展示效果也不错，似乎最后同学们投票得分在软工项目中挺高的。我们之后还从白老师和裴老师那里拿到了一些纪念品。

![](/img/in-post/cpu/se.png)

# 操作系统大实验

> 不可避免地会遇到系统 bug：很多  
> 不可避免地会遇到 CPU bug：很多  
> 不可避免地会遇到看不懂的 Rust 语法：很多

虽然已经忘了最早从什么时候开始决定要参加「龙芯杯」的，但是至少在大三下之前这件事已经确定了。我们本想在这个学期开始准备「龙芯杯」，恰好「操作系统」课程也有个可选的大实验，我们便想在这里做 Linux 的移植。但是因为和老师有些争议（印象里老师觉得这是操作系统的课还是主要关注系统而不是硬件上）我们最后并没有在这时候开始准备「龙芯杯」，而是决定将当时的一个用 Rust 写的教学操作系统 rCore 移植到 MIPS 平台上并且在之前「TrivialMIPS」上跑起来。

整个移植的过程中我们遇到了很多奇怪的错误，再加上因为不知道是系统有问题还是 CPU 写的有问题，同时还有可能是因为没搞懂 Rust 而造成的问题，整个移植过程遇到了很多神秘现象。甚至有一些问题在最后都没有成功弄清楚原因，只知道用某些方法可以让它们暂时隐藏起来。

当然，在这个过程中也发现了一些之前 CPU 上遗留的问题，下面是一些因为 CPU 的问题而造成的神秘现象的例子。其中有一个是因为测试编写并不完善而导致的问题，MIPS 的计算 `0` 和 `1` 个数的指令 `clz/clo` 的代码中有着一个 typo，使得在 BuddySystem 里使用它时有时候会得到不正确的结果，进而导致内存分配出问题……

![](/img/in-post/cpu/os-1.png)

还有就是因为一些细节问题而导致的系统调用号没有被正确计算

![](/img/in-post/cpu/os-2.png)

下面这个神奇的问题的表现也很有趣：本应是 `busybox` 的输出变成了「忙碌的公牛」

![](/img/in-post/cpu/os-3.png)

其它的部分随着时间相隔较远，我也已经记不太清楚了，在此就不细说了……

# 「龙芯杯」之旅

>  TrivialMIPS is nontrivial!

在大三下学期结束后就是暑期的「专业实践」环节了，大家可以选不同的方向去实习、暑研或者做一些项目。我们当然就选择准备「龙芯杯」，除了 Harry 之外这时队伍里还加了刘晓义。这时「龙芯杯」已经举办了两届了，第一届的时候清华的「[NaiveMIPS](https://github.com/z4yx/NaiveMIPS-HDL)」在大家只有简单的流水线的情况下额外还运行起了 Linux 操作系统以及板子上的各类外设，毫无疑问地拿到了特等奖。到了第二届时，参赛队的整体水平突然提高，清华做的是一个双核的 CPU，但是不幸的是用于计算性能分数的测试只能在一个核心跑，但是双核导致频率下降最终的性能分吃了亏，只拿到了第二。

在准备「龙芯杯」的第一次会上老师告诉我们说吴老板想要把这个奖拿回来，顿时感觉压力增大了许多（当然特等奖的奖金还是很多的）。

#### 顺序？乱序？

由于之前「TrivialMIPS」实际上还是较为简单，而且似乎还藏着各种神秘的 bug，再加上之前「操作系统」课上调试时遇到的各种原因不明的现象，在讨论之后我们决定从头开始设计并且实现一个 MIPS CPU。为了有一些区别，这回名字当然就改成「NonTrivialMIPS」了。

接下来的问题就是我们究竟要做一个什么样的架构。当然不会是一个原始的五级流水线，双发射肯定是要保留下来，剩下的问题是究竟要用顺序还是乱序。这里要先提一下，在这一届「龙芯杯」的性能评价方法有了一些变化，原先是只看在测试程序上的耗时，今年变为了同时考虑频率和 IPC 两个指标。当然，这也是为了鼓励参赛队实现一些更复杂的架构。

回到顺序和乱序的问题，因为顺序双发射有一些之前「TrivialMIPS」的经验，所以实现起来应该会稍微容易一些，但是我担心的是 IPC 这个指标最后有可能上不去。当然乱序的话一是并没有实现经验，而是频率不一定能调的比较高。权衡之下，我们决定先实现一个顺序双发射，之后再尝试将其改成乱序。

为了避免因为没想清楚而导致的一堆细节上的问题，这回我先花了一段时间读了一遍「计算机体系结构：量化研究方法」的相关章节。顺便也大致浏览了一下开源的一些核的设计。这时最初的设计大约就确定下来了。为了之后修改乱序方便，以及避免一下之前「TrivialMIPS」里遇到的麻烦的问题，我参考了「量化研究方法」和一些开源核的想法把取指和之后的执行等分开，用一个 FIFO 把取指后的指令先存下来。这样后期修改乱序可以只修改后面的部分而不需要动取指模块。

正式开始写应该是六月底七月初的时候，接下来的一周多时间我把流水线最初的版本完成了，再加上一个指令 cache。因为指令和数据 cache 计划都是有两级流水，所以整个流水线就变成了七级的（我在这里额外说明一下，这回和之前「TrivialMIPS」有个很大的不同是 cache 的存在变得十分重要，因为这时访存的延时可能会有数十个周期了）。再调试了一两天后，我们第一次通过了功能测试和性能测试。这时 lxy 的数据 cache 还没有写完，我们的得分大约只有 5 分。和前一年的特等奖西工大的 72 分相距甚远。

又过了几天，lxy 把数据 cache 也写好了，我们的性能分这时候提升到了 32 左右。这时频率仅仅只有 50MHz，下一步就要开始提高频率了。如果什么都不做，看起来最多只能提升到 80MHz 左右，性能分估计也不会超过 50 分。看了看关键路径，几乎都在 cache 上面。最后，我们考虑两个 cache 都增加了一级流水，频率也顺利地提升到了 100MHz。这时性能分已经达到了 65 分，似乎再努力一下就可以赶上去年特等奖了？

这时通过初赛肯定是没有问题了，我便开始考虑尝试把流水线改成乱序的版本。当然，在写之前同样也先想了两天应该做什么。实际写花的时间也比想象的来得快，大约一周时间就把功能测试通过了。这段时间我养成了一个非常不好的习惯，那就是写代码的时候旁边总要放一些剧看，写乱序的过程中顺便把「一人之下」给看了两遍…

通过功能测试之后我发现频率似乎成了一个很大的坎。之前顺序的设计已经到达了 100MHz，但是这个乱序似乎最多 80MHz 就不太能上去了，关键是组合逻辑太复杂了。至于 IPC，因为访存模块（load store unit，LSU）并没有用很好的方式处理「写后读」冲突，导致暂停较多在性能测试上甚至不如之前的顺序。到这里乱序的尝试暂时宣告失败，我决定还是回头努力调顺序的频率和 IPC。

#### 挤牙膏

> 性能就像海绵里的水，只要愿挤，总还是有的。 ——不是鲁迅

在决定回到顺序的设计后我们基本上进入了「挤牙膏」的阶段，IPC 看起来已经不太容易再变好了，能调的只有频率。调频率的过程十分枯燥，每次改完之后都需要重新等 30 至 40 分钟不等的综合看最终的时序分析来进行下一步的修改。

在这段时间发生了一些很有趣的事情，因为这时候暂时还处于「专业实践」小学期中，所以我们每周二都会和老师开一次会汇报一下进度。有趣的是，每次性能大幅提升大都是汇报时康总在的时候。只要康总在现场，性能分就噌的往上涨。

在给各种重要性或使用频率较低的指令增加流水和暂停之后，我们终于达到了 110MHz，最终得分大约是 71 分，这时已经和去年的特等奖持平了。

#### 令人绝望的随机现象

#### 比赛前夜的「炼丹」

#### 决赛

# 后话